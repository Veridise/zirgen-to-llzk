// RUN: zklang %s | FileCheck %s

component Head<T: Type, N: Val>(arr: Array<T, N>) {
  arr[0]
}

component A<N: Val>() {
  Head<Val, 3>([N,N+1,N+2])
}

component B() {
  Head<A<1>, 2>([A<1>(), A<1>()])
}

component Top() {
  a := A<1>();
  b := B();
  a = b;
}

//      CHECK: module attributes {veridise.lang = "llzk"} {
// CHECK-NEXT:   llzk.struct @Head<[@T, @N]> {
// CHECK-NEXT:     field @"$super" : !llzk.tvar<@T>
// CHECK-NEXT: 
// CHECK-NEXT:     func @compute(%arr: !llzk.array<@N x !llzk.tvar<@T>>) -> !llzk.struct<@Head<[@T, @N]>> {
// CHECK-NEXT:       %self = new_struct : !llzk.struct<@Head<[@T, @N]>>
// CHECK-NEXT:       %1 = index.constant 0
// CHECK-NEXT:       %2 = readarr %arr[%1] : !llzk.array<@N x !llzk.tvar<@T>>, !llzk.tvar<@T>
// CHECK-NEXT:       writef %self[@"$super"] = %2 : !llzk.struct<@Head<[@T, @N]>>, !llzk.tvar<@T>
// CHECK-NEXT:       return %self : !llzk.struct<@Head<[@T, @N]>>
// CHECK-NEXT:     }
// CHECK-NEXT: 
// CHECK-NEXT:     func @constrain(%self: !llzk.struct<@Head<[@T, @N]>>, %arr: !llzk.array<@N x !llzk.tvar<@T>>) {
// CHECK-NEXT:       %1 = index.constant 0
// CHECK-NEXT:       %2 = readarr %arr[%1] : !llzk.array<@N x !llzk.tvar<@T>>, !llzk.tvar<@T>
// CHECK-NEXT:       %3 = readf %self[@"$super"] : !llzk.struct<@Head<[@T, @N]>>, !llzk.tvar<@T>
// CHECK-NEXT:       emit_eq %2, %3 : !llzk.tvar<@T>
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }
// CHECK-NEXT: 
// CHECK-NEXT:   llzk.struct @A<[@N]> {
// CHECK-NEXT:     field @"$super" : !llzk.struct<@Head<[!llzk.felt, 3]>>
// CHECK-NEXT: 
// CHECK-NEXT:     func @compute() -> !llzk.struct<@A<[@N]>> {
// CHECK-NEXT:       %self = new_struct : !llzk.struct<@A<[@N]>>
// CHECK-NEXT:       %1 = read_const @N : !llzk.felt
// CHECK-NEXT:       %2 = constfelt 1
// CHECK-NEXT:       %3 = constfelt 2
// CHECK-NEXT:       %4 = add %1, %2
// CHECK-NEXT:       %5 = add %1, %3
// CHECK-NEXT:       %6 = new_array %1, %4, %5 : !llzk.array<3 x !llzk.felt>
// CHECK-NEXT:       %7 = call @Head::@compute(%6) : (!llzk.array<3 x !llzk.felt>) -> !llzk.struct<@Head<[!llzk.felt, 3]>>
// CHECK-NEXT:       writef %self[@"$super"] = %7 : !llzk.struct<@A<[@N]>>, !llzk.struct<@Head<[!llzk.felt, 3]>>
// CHECK-NEXT:       return %self : !llzk.struct<@A<[@N]>>
// CHECK-NEXT:     }
// CHECK-NEXT: 
// CHECK-NEXT:     func @constrain(%self: !llzk.struct<@A<[@N]>>) {
// CHECK-NEXT:       %0 = readf %self[@"$super"] : !llzk.struct<@A<[@N]>>, !llzk.struct<@Head<[!llzk.felt, 3]>>
// CHECK-NEXT:       %1 = read_const @N : !llzk.felt
// CHECK-NEXT:       %2 = constfelt 1
// CHECK-NEXT:       %3 = constfelt 2
// CHECK-NEXT:       %4 = add %1, %2
// CHECK-NEXT:       %5 = add %1, %3
// CHECK-NEXT:       %arr = new_array %1, %4, %5 : !llzk.array<3 x !llzk.felt>
// CHECK-NEXT:       call @Head::@constrain(%0, %arr) : (!llzk.struct<@Head<[!llzk.felt, 3]>>, !llzk.array<3 x !llzk.felt>) -> ()
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }
// CHECK-NEXT: 
// CHECK-NEXT:   llzk.struct @B {
// CHECK-NEXT:     field @"$super" : !llzk.struct<@Head<[!llzk.struct<@A<[1]>>, 2]>>
// CHECK-NEXT: 
// CHECK-NEXT:     func @compute() -> !llzk.struct<@B> {
// CHECK-NEXT:       %self = new_struct : !llzk.struct<@B>
// CHECK-NEXT:       %1 = call @A::@compute() : () -> !llzk.struct<@A<[1]>>
// CHECK-NEXT:       %2 = call @A::@compute() : () -> !llzk.struct<@A<[1]>>
// CHECK-NEXT:       %3 = new_array %1, %2 : !llzk.array<2 x !llzk.struct<@A<[1]>>>
// CHECK-NEXT:       %4 = call @Head::@compute(%3) : (!llzk.array<2 x !llzk.struct<@A<[1]>>>) -> !llzk.struct<@Head<[!llzk.struct<@A<[1]>>, 2]>>
// CHECK-NEXT:       writef %self[@"$super"] = %4 : !llzk.struct<@B>, !llzk.struct<@Head<[!llzk.struct<@A<[1]>>, 2]>>
// CHECK-NEXT:       return %self : !llzk.struct<@B>
// CHECK-NEXT:     }
// CHECK-NEXT: 
// CHECK-NEXT:     func @constrain(%self: !llzk.struct<@B>) {
// CHECK-NEXT:       %0 = readf %self[@"$super"] : !llzk.struct<@B>, !llzk.struct<@Head<[!llzk.struct<@A<[1]>>, 2]>>
// CHECK-NEXT:       %arr = new_array : !llzk.array<2 x !llzk.struct<@A<[1]>>>
// CHECK-NEXT:       call @Head::@constrain(%0, %arr) : (!llzk.struct<@Head<[!llzk.struct<@A<[1]>>, 2]>>, !llzk.array<2 x !llzk.struct<@A<[1]>>>) -> ()
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }
// CHECK-NEXT: 
// CHECK-NEXT:   llzk.struct @Top {
// CHECK-NEXT:     field @"$super" : !llzk.struct<@VoidComponent>
// CHECK-NEXT:     field @a : !llzk.struct<@A<[1]>>
// CHECK-NEXT:     field @b : !llzk.struct<@B>
// CHECK-NEXT: 
// CHECK-NEXT:     func @compute() -> !llzk.struct<@Top> {
// CHECK-NEXT:       %self = new_struct : !llzk.struct<@Top>
// CHECK-NEXT:       %1 = call @A::@compute() : () -> !llzk.struct<@A<[1]>>
// CHECK-NEXT:       writef %self[@a] = %1 : !llzk.struct<@Top>, !llzk.struct<@A<[1]>>
// CHECK-NEXT:       %2 = call @B::@compute() : () -> !llzk.struct<@B>
// CHECK-NEXT:       writef %self[@b] = %2 : !llzk.struct<@Top>, !llzk.struct<@B>
// CHECK-NEXT:       %3 = call @VoidComponent::@compute() : () -> !llzk.struct<@VoidComponent>
// CHECK-NEXT:       writef %self[@"$super"] = %3 : !llzk.struct<@Top>, !llzk.struct<@VoidComponent>
// CHECK-NEXT:       return %self : !llzk.struct<@Top>
// CHECK-NEXT:     }
// CHECK-NEXT: 
// CHECK-NEXT:     func @constrain(%self: !llzk.struct<@Top>) {
// CHECK-NEXT:       %0 = readf %self[@a] : !llzk.struct<@Top>, !llzk.struct<@A<[1]>>
// CHECK-NEXT:       call @A::@constrain(%0) : (!llzk.struct<@A<[1]>>) -> ()
// CHECK-NEXT:       %1 = readf %self[@b] : !llzk.struct<@Top>, !llzk.struct<@B>
// CHECK-NEXT:       call @B::@constrain(%1) : (!llzk.struct<@B>) -> ()
// CHECK-NEXT:       %2 = readf %0[@"$super"] : !llzk.struct<@A<[1]>>, !llzk.struct<@Head<[!llzk.felt, 3]>>
// CHECK-NEXT:       %3 = readf %2[@"$super"] : !llzk.struct<@Head<[!llzk.felt, 3]>>, !llzk.felt
// CHECK-NEXT:       %4 = readf %1[@"$super"] : !llzk.struct<@B>, !llzk.struct<@Head<[!llzk.struct<@A<[1]>>, 2]>>
// CHECK-NEXT:       %5 = readf %4[@"$super"] : !llzk.struct<@Head<[!llzk.struct<@A<[1]>>, 2]>>, !llzk.struct<@A<[1]>>
// CHECK-NEXT:       %6 = readf %5[@"$super"] : !llzk.struct<@A<[1]>>, !llzk.struct<@Head<[!llzk.felt, 3]>>
// CHECK-NEXT:       %7 = readf %6[@"$super"] : !llzk.struct<@Head<[!llzk.felt, 3]>>, !llzk.felt
// CHECK-NEXT:       emit_eq %3, %7 : !llzk.felt
// CHECK-NEXT:       %8 = readf %self[@"$super"]: !llzk.struct<@Top>, !llzk.struct<@VoidComponent>
// CHECK-NEXT:       call @VoidComponent::@constrain(%8) : (!llzk.struct<@VoidComponent>) -> ()
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }
// CHECK-NEXT: 
// CHECK-NEXT:   llzk.struct @VoidComponent {
// CHECK-NEXT:     func @compute() -> !llzk.struct<@VoidComponent> {
// CHECK-NEXT:       %self = new_struct : !llzk.struct<@VoidComponent>
// CHECK-NEXT:       return %self : !llzk.struct<@VoidComponent>
// CHECK-NEXT:     }
// CHECK-NEXT: 
// CHECK-NEXT:     func @constrain(%self: !llzk.struct<@VoidComponent>) { return }
// CHECK-NEXT:   }
// CHECK-NEXT: }
// CHECK-NEXT: 
