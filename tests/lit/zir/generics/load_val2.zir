// RUN: zklang %s | FileCheck %s

component A<N: Val>() {
  [N,N+1]
}

component Top() {
  a := A<1>();
}

//      CHECK:   llzk.struct @A<[@N]> {
// CHECK-NEXT:     field @"$super" : !llzk.array<2 x !llzk.felt>
// CHECK-NEXT:     field @"$temp_0" : !llzk.array<2 x !llzk.felt>
// CHECK-NEXT:     field @"$temp" : !llzk.felt
// CHECK-NEXT:     func @compute() -> !llzk.struct<@A<[@N]>> {
// CHECK-NEXT:       %felt_const_1 = constfelt  1
// CHECK-NEXT:       %0 = read_const @N : !llzk.felt
// CHECK-NEXT:       %1 = add %0, %felt_const_1 : !llzk.felt, !llzk.felt
// CHECK-NEXT:       %self = new_struct : <@A<[@N]>>
// CHECK-NEXT:       writef %self[@"$temp"] = %1 : <@A<[@N]>>, !llzk.felt
// CHECK-NEXT:       %2 = readf %self[@"$temp"] : <@A<[@N]>>, !llzk.felt
// CHECK-NEXT:       %array = new_array %0, %2 : <2 x !llzk.felt>
// CHECK-NEXT:       writef %self[@"$temp_0"] = %array : <@A<[@N]>>, !llzk.array<2 x !llzk.felt>
// CHECK-NEXT:       %3 = readf %self[@"$temp_0"] : <@A<[@N]>>, !llzk.array<2 x !llzk.felt>
// CHECK-NEXT:       writef %self[@"$super"] = %3 : <@A<[@N]>>, !llzk.array<2 x !llzk.felt>
// CHECK-NEXT:       return %self : !llzk.struct<@A<[@N]>>
// CHECK-NEXT:     }
// CHECK-NEXT:     func @constrain(%arg0: !llzk.struct<@A<[@N]>>) {
// CHECK-NEXT:       %0 = read_const @N : !llzk.felt
// CHECK-NEXT:       %1 = readf %arg0[@"$temp"] : <@A<[@N]>>, !llzk.felt
// CHECK-NEXT:       %2 = readf %arg0[@"$temp_0"] : <@A<[@N]>>, !llzk.array<2 x !llzk.felt>
// CHECK-NEXT:       return
// CHECK-NEXT:     }
// CHECK-NEXT:   }

