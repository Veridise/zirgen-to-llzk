// RUN: zklang -o - %s | FileCheck %s

extern LookupDelta(table: Val, index: Val, count: Val);

component StateLoadRoot() { 0 }
component StateResume() { 1 }
component StateSuspend() { 4 }
component StateStoreRoot() { 5 }
component StateControlTable() { 6 }
component StateControlDone() { 7 }

component StatePoseidonEntry() { 16 }

component StateDecode() { 48 }

component SuspendPcWord() { 0x3fffc084 }
component SuspendModeWord() { 0x3fffc085 }
component OutputWord() { 0x3fffc090 }
component InputWord() { 0x3fffc098 }
component RootWord() { 0x43fffff8 }

argument CycleArg(count: Val, cycle: Val) {
  public count := NondetReg(count);
  public cycle := NondetReg(cycle);
  LookupDelta(0, cycle, count);
}

component IsCycle(x: Val) {
  arg := CycleArg(1, x);
  arg.count = 1;
  arg.cycle = x;
}

component ValU32(low: Val, high: Val) {
  public low := low;
  public high := high;
}

extern MemoryDelta(addr: Val, cycle: Val, dataLow: Val, dataHigh: Val, count: Val);

argument MemoryArg(count: Val, addr: Val, cycle: Val, data: ValU32) {
  public count := NondetReg(count);
  public addr := NondetReg(addr);
  public cycle := NondetReg(cycle);
  public dataLow := NondetReg(data.low);
  public dataHigh := NondetReg(data.high);
  MemoryDelta(addr, cycle, dataLow, dataHigh, count);
}

component GetData(arg: MemoryArg, diffLow: Val, diffHigh: Val) {
  public diffLow := diffLow;
  public diffHigh := diffHigh;
  ValU32(arg.dataLow, arg.dataHigh)
}

component MemoryTxnResult(prevCycle: Val, prevData: ValU32, data: ValU32) {
  public prevCycle := prevCycle;
  public prevData := prevData;
  public data := data;
}

extern GetMemoryTxn(addr: Val): MemoryTxnResult;

component MemoryIO(memCycle: Val, addr: Val) {
  ret := GetMemoryTxn(addr);
  public oldTxn := MemoryArg(-1, addr, ret.prevCycle, ret.prevData);
  public newTxn := MemoryArg(1, addr, memCycle, ret.data);
  oldTxn.count = -1;
  newTxn.count = 1;
  newTxn.cycle = memCycle;
  AliasLayout!(oldTxn.addr, newTxn.addr);
  oldTxn.addr = newTxn.addr;
  newTxn.addr = addr;
}

component IsRead(io: MemoryIO) {
  io.oldTxn.dataLow = io.newTxn.dataLow;
  io.oldTxn.dataHigh = io.newTxn.dataHigh;
}

component IsForward(io: MemoryIO) {
  IsCycle(io.newTxn.cycle - io.oldTxn.cycle);
}

component MemoryRead(cycle: Reg, addr: Val) {
  io := MemoryIO(2*cycle, addr);
  IsRead(io);
  IsForward(io);
  GetData(io.newTxn, 0, 1)
}

component MemoryWrite(cycle: Reg, addr: Val, data: ValU32) {
  public io := MemoryIO(2*cycle + 1, addr);
  IsForward(io);
  io.newTxn.dataLow = data.low;
  io.newTxn.dataHigh = data.high;
}

component MemoryPageIn(cycle: Reg, addr: Val) {
  io := MemoryIO(2*cycle, addr);
  IsRead(io);
  GetData(io.newTxn, 0, io.newTxn.cycle - io.oldTxn.cycle)
}

component MemoryPageOut(cycle: Reg, addr: Val) {
  io := MemoryIO(2*cycle, addr);
  IsForward(io);
  GetData(io.oldTxn, io.newTxn.dataLow - io.oldTxn.dataLow,
    io.newTxn.dataHigh - io.oldTxn.dataHigh)
}

component IsZero(val: Val) {
  // Nondeterministically 'guess' the result
  isZero := NondetReg(Isz(val));

  // Compute the inverse (for non-zero values), for zero values, Inv returns 0
  inv := NondetReg(Inv(val));

  // Assert that the result is a bit
  isZero * (1 - isZero) = 0;
  // If isZero is 0 (i.e. nonzero) then val must have an inverse
  val * inv = 1 - isZero;
  // If isZero is 1, then val must be zero
  isZero * val = 0;
  // If isZero is 1, then inv must be zero
  isZero * inv = 0;
  // Make the reuslt Return 'isZero'
  isZero
}

component InstInput(major: Val, minor: Val, pc_u32: ValU32, state: Val, mode: Val) {
  public major := major;
  public minor := minor;
  public pc_u32 := pc_u32;
  public state := state;
  public mode := mode;
}

component BigIntTopState(polyOp: Val, coeff: Val, witness: Array<Val, 16>) {
  public polyOp := polyOp;
  public coeff := coeff;
  public witness := witness;
}

component BigIntTopStateNull() {
  BigIntTopState(0, 0, for i : 0..16 { 0 })
}

component InstOutputBase(new_pc: ValU32, new_state: Val, new_mode: Val, topState: BigIntTopState) {
  public new_pc := new_pc;
  public new_state := new_state;
  public new_mode := new_mode;
  public topState := topState;
}

component InstOutput(new_pc: ValU32, new_state: Val, new_mode: Val) {
  InstOutputBase(new_pc, new_state, new_mode, BigIntTopStateNull())
}

component DigestReg(values: Array<ValU32, 8>) {
  public values := for v : values {
    public low := Reg(v.low);
    public high := Reg(v.high);
  };
}

component ControlLoadRoot(cycle: Reg, input: InstInput) {
  global stateIn : DigestReg;
  input.state = StateLoadRoot();
  // Verify page in
  for i : 0..8 {
    mem := MemoryPageIn(cycle, RootWord() + i);
    stateIn.values[i].low = mem.low;
    stateIn.values[i].high = mem.high;
  };
  InstOutput(ValU32(0, 0), StatePoseidonEntry(), 0)
}

component ControlResume(cycle: Reg, ii: InstInput) {
  ii.state = StateResume();
  // We use PC zero state to determine if we in cycle 1 or 2 of suspend
  pcZero := IsZero(ii.pc_u32.low + ii.pc_u32.high);
  if (pcZero) {
    // In step 1
    pc := MemoryRead(cycle, SuspendPcWord());
    mode := MemoryRead(cycle, SuspendModeWord());
    InstOutput(pc, StateResume(), mode.low)
  } else {
    global input : DigestReg;
    for i : 0..8 {
      MemoryWrite(cycle, InputWord() + i,
        ValU32(input.values[i].low, input.values[i].high));
    };
    InstOutput(ii.pc_u32, StateDecode(), ii.mode)
  }
}

component ControlSuspend(cycle: Reg, input: InstInput) {
  // We use PC zero state to determine if we in cycle 1 or 2 of suspend
  pcZero := IsZero(input.pc_u32.low + input.pc_u32.high);
  if (pcZero) {
    input.state = StateSuspend();
    // In step 2
    global isTerminate: Reg;
    // Write from memory if terminating, or zeros if suspending
    global output := DigestReg(
      for i : 0..8 { MemoryRead(cycle, OutputWord() + i) }
    );
    if (1 - isTerminate) {
      global termA0low := Reg(0);
      global termA0high := Reg(0);
      global termA1low := Reg(0);
      global termA1high := Reg(0);
    };

    // Begin page out
    InstOutput(ValU32(0, 0), StatePoseidonEntry(), 3)
  } else {
    // In step 1
    // Must either enter nondeterministically from decode or via ecall
    state := Reg(input.state);  // Registerize because state is degree 2
    (state - StateDecode()) * (state - StateSuspend()) = 0;
    // Write to the global
    // If state == StateDecode, this is zero, otherwise it's one
    global isTerminate := Reg((state - StateDecode()) / (StateSuspend() - StateDecode()));
    // Write PC + original mode
    MemoryWrite(cycle, SuspendPcWord(), input.pc_u32);
    MemoryWrite(cycle, SuspendModeWord(), ValU32(input.mode, 0));
    // Go to cycle 2 (i.e. write root)
    InstOutput(ValU32(0, 0), StateSuspend(), input.mode)
  }
}

component ControlStoreRoot(cycle: Reg, input: InstInput) {
  input.state = StateStoreRoot();
  global stateOut := DigestReg(
    for i : 0..8 {
      MemoryPageOut(cycle, RootWord() + i)
    }
  );
  InstOutput(ValU32(0, 0), StateControlTable(), 0)
}

component ControlDone(cycle: Reg, input: InstInput) {
  input.state = StateControlDone();
  global isTerminate: Reg;
  global shutdownCycle: Reg;
  if ((1 - input.mode) * (1 - isTerminate)) {
    Log("Verifying end state");
    IsCycle(cycle - shutdownCycle);
  } else {
    // NOP
  };
  InstOutput(ValU32(0, 0), StateControlDone(), 1)
}

//CHECK: TODO
