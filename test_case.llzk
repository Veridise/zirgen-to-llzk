#divlen = affine_map<()[N, P] -> (N floordiv P)>

module attributes {veridise.lang = "llzk"} {
  llzk.struct @S<[@N, @P]> {
    func @compute(%in: !llzk.array<#divlen x !llzk.felt>) -> !llzk.struct<@S<[@N, @P]>> {
      %self = new_struct : <@S<[@N, @P]>>
      %1 = arith.constant 0 : index 
      %0 = readarr %in[%1] : !llzk.array<#divlen x !llzk.felt>, !llzk.felt
      return %self : !llzk.struct<@S<[@N, @P]>>
    }
    func @constrain(%self: !llzk.struct<@S<[@N, @P]>>, %in: !llzk.array<#divlen x !llzk.felt>) {
      return
    }
  }

  llzk.struct @B<[@N]> {
    func @compute() -> !llzk.struct<@B<[@N]>> {
      %self = new_struct : <@B<[@N]>>
      return %self : !llzk.struct<@B<[@N]>>
    }
    func @constrain(%self: !llzk.struct<@B<[@N]>>) { return }
  }

  llzk.struct @A<[@N]> {
    func @compute() -> !llzk.struct<@A<[@N]>> {
      %self = new_struct : <@A<[@N]>>
      %8 = read_const @N : index
      %2 = arith.constant 2 : index 
      %a = new_array{()[%8, %2]} : !llzk.array<#divlen x !llzk.felt>
      %b = call @S::@compute(%a) : (!llzk.array<#divlen x !llzk.felt>) -> !llzk.struct<@S<[@N, 2]>>

      %c = call @B::@compute(){()[%8, %2]} : () -> !llzk.struct<@B<[#divlen]>>
      return %self : !llzk.struct<@A<[@N]>>
    }

    func @constrain(%self: !llzk.struct<@A<[@N]>>) {
      return
    }
  }
}
