
// Copyright 2024 Veridise, Inc.

#include "ZirToZkir/Dialect/ZMIR/IR/Ops.h"
#include "ZirToZkir/Dialect/ZMIR/Transforms/PassDetail.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinAttributes.h"
#include "mlir/IR/BuiltinOps.h"
#include "mlir/IR/SymbolTable.h"
#include "zirgen/Dialect/ZHL/IR/ZHL.h"
#include <cassert>
#include <llvm/Support/Debug.h>
#include <mlir/Transforms/DialectConversion.h>
#include <tuple>

using namespace mlir;

namespace zkc::Zmir {

namespace {

class PendingSymbolRenames {
public:
  explicit PendingSymbolRenames(ModuleOp);

  bool hasPendingRenames() const;
  void removeOp(Operation *);
  void addOp(Operation *, StringAttr);
  LogicalResult applyPendingRenames();

private:
  SymbolTable st;
  // Maps the autogenerated name to the desired symbol name
  std::vector<std::tuple<mlir::Operation *, mlir::StringAttr, mlir::StringAttr>>
      pending;
};

PendingSymbolRenames::PendingSymbolRenames(ModuleOp mod) : st(mod) {}

bool PendingSymbolRenames::hasPendingRenames() const {
  return !pending.empty();
}

/// Removes the op from the symbol table and from the pendings list if found
void PendingSymbolRenames::removeOp(Operation *op) {
  st.remove(op); // Only remove from the symbol table
  auto toRemove = std::remove_if(pending.begin(), pending.end(),
                                 [&](auto t) { return std::get<0>(t) == op; });
  pending.erase(toRemove, pending.end());
}

/// Inserts the operation in the symbol table and marks it as
/// pending with the desired name.
void PendingSymbolRenames::addOp(Operation *op, StringAttr desired) {
  pending.push_back({op, st.insert(op), desired});
}

/// Applies the pending rename operations.
/// The queue of pending operations gets cleared regardless
/// of the result of the rename operation.
LogicalResult PendingSymbolRenames::applyPendingRenames() {
  std::vector<LogicalResult> results;
  std::transform(pending.begin(), pending.end(), std::back_inserter(results),
                 [&](auto rename) {
                   // Give them more descriptive names
                   auto *op = std::get<0>(rename);
                   auto &assigned = std::get<1>(rename);
                   auto &desired = std::get<2>(rename);

                   // No need to rename if they are already equal
                   if (assigned == desired)
                     return mlir::success();
                   llvm::dbgs() << "Attempting to rename " << assigned << " to "
                                << desired << "\n";

                   return st.rename(op, desired);
                 });
  pending.clear();

  return mlir::success(
      std::all_of(results.begin(), results.end(), mlir::succeeded));
}

class SplitComponentOpPattern : public mlir::OpConversionPattern<ComponentOp> {
public:
  template <typename... Args>
  SplitComponentOpPattern(PendingSymbolRenames &pending, Args &&...args)
      : ::OpConversionPattern<ComponentOp>(std::forward<Args>(args)...),
        pending(pending) {}

  mlir::LogicalResult
  matchAndRewrite(ComponentOp, OpAdaptor,
                  mlir::ConversionPatternRewriter &) const override;

private:
  mlir::func::FuncOp fillFunc(SplitComponentOp op, mlir::StringRef,
                              mlir::FunctionType funcType, Region &original,
                              mlir::ConversionPatternRewriter &rewriter) const;

  PendingSymbolRenames &pending;
};

class ReplaceReturnOpInConstrainFunc
    : public mlir::OpConversionPattern<mlir::func::ReturnOp> {
public:
  using OpConversionPattern<mlir::func::ReturnOp>::OpConversionPattern;

  mlir::LogicalResult
  matchAndRewrite(func::ReturnOp, OpAdaptor,
                  ConversionPatternRewriter &) const override;
};

LogicalResult SplitComponentOpPattern::matchAndRewrite(
    ComponentOp op, OpAdaptor adaptor,
    mlir::ConversionPatternRewriter &rewriter) const {

  SplitComponentOp newOp = rewriter.create<SplitComponentOp>(
      op.getLoc(), op->getResultTypes(), op->getOperands(), op->getAttrs());

  // Make the symbol table aware of the new component op
  // but don't name it like the old op right now.
  pending.removeOp(op);
  pending.addOp(newOp, op.getSymNameAttr());
  rewriter.replaceOp(op.getOperation(), newOp.getOperation());

  {
    mlir::OpBuilder::InsertionGuard insertionGuard(rewriter);
    auto *block = rewriter.createBlock(&newOp.getRegion());
    rewriter.setInsertionPointToStart(block);

    // Copy the field definitions
    for (auto paramOp : op.getOps<FieldDefOp>()) {
      rewriter.clone(*paramOp.getOperation());
    }
    // Copy additional functions declared (like externs)
    for (auto f : op.getOps<mlir::func::FuncOp>()) {
      if (f == op.getBodyFunc())
        continue;
      rewriter.clone(*f.getOperation());
    }

    auto bodyFuncType = op.getBodyFunc().getFunctionType();

    fillFunc(newOp, newOp.getBodyFuncName(), bodyFuncType,
             op.getBodyFunc().getRegion(), rewriter);
    {
      std::vector<mlir::Type> constrainFuncArgTypes({op.getType()});
      constrainFuncArgTypes.insert(constrainFuncArgTypes.end(),
                                   bodyFuncType.getInputs().begin(),
                                   bodyFuncType.getInputs().end());
      auto constrainFuncType =
          rewriter.getFunctionType(constrainFuncArgTypes, TypeRange());
      auto constrainFunc =
          fillFunc(newOp, newOp.getConstrainFuncName(), constrainFuncType,
                   op.getBodyFunc().getRegion(), rewriter);
      // Insert the self argument for the constrain function as it will be
      // required by zkir.
      assert(!constrainFunc.getRegion().empty() &&
             "was expecting a filled out function");

      auto &b = constrainFunc.getRegion().front();
      // If there are no arguments just add it.
      // If there are arguments already insert it at the beginning
      // and shift all other arguments
      if (b.args_empty()) {
        b.addArgument(op.getType(), op.getLoc());
      } else {
        b.insertArgument(b.args_begin(), op.getType(),
                         b.args_begin()->getLoc());
      }
    }
  }

  return mlir::success();
}

mlir::func::FuncOp SplitComponentOpPattern::fillFunc(
    SplitComponentOp op, llvm::StringRef name, mlir::FunctionType funcType,
    Region &original, mlir::ConversionPatternRewriter &rewriter) const {

  std::vector<mlir::NamedAttribute> attrs = {
      mlir::NamedAttribute(rewriter.getStringAttr("sym_visibility"),
                           rewriter.getStringAttr("nested"))};

  auto bodyOp =
      rewriter.create<mlir::func::FuncOp>(op.getLoc(), name, funcType, attrs);

  rewriter.cloneRegionBefore(original, bodyOp.getRegion(),
                             bodyOp.getRegion().end());
  return bodyOp;
}

LogicalResult ReplaceReturnOpInConstrainFunc::matchAndRewrite(
    func::ReturnOp op, OpAdaptor adaptor,
    ConversionPatternRewriter &rewriter) const {
  auto func = op.getParentOp();
  auto comp = mlir::dyn_cast<ComponentInterface>(func->getParentOp());
  if (!comp || (func != comp.getConstrainFunc() && !comp.hasUnifiedBody())) {
    return mlir::failure();
  }

  // At this point we know we are in a return op of a constrain function, so we
  // need to make a void return since that's the return type of that function.
  rewriter.replaceOpWithNewOp<func::ReturnOp>(op, TypeRange(), ValueRange());

  return mlir::success();
}

class SplitComponentBodyPass
    : public SplitComponentBodyBase<SplitComponentBodyPass> {

  void runOnOperation() override {
    auto op = getOperation();
    PendingSymbolRenames pending(op);

    mlir::MLIRContext *ctx = op->getContext();
    mlir::RewritePatternSet patterns(ctx);

    patterns.add<SplitComponentOpPattern>(pending, ctx);
    patterns.add<ReplaceReturnOpInConstrainFunc>(ctx);

    // Set conversion target
    mlir::ConversionTarget target(*ctx);
    target.addLegalDialect<zkc::Zmir::ZmirDialect, mlir::func::FuncDialect>();
    target.addLegalOp<mlir::UnrealizedConversionCastOp, mlir::ModuleOp>();
    target.addIllegalDialect<zirgen::Zhl::ZhlDialect>();
    target.addIllegalOp<Zmir::ComponentOp>();

    // Return types may change so we need to adjust the return ops
    target.addDynamicallyLegalOp<func::ReturnOp>([](func::ReturnOp ret) {
      return ret.getOperandTypes() ==
             ret.getParentOp<func::FuncOp>().getFunctionType().getResults();
    });

    // Call partialTransformation
    if (mlir::failed(
            mlir::applyFullConversion(op, target, std::move(patterns))) ||
        // If the transformation went OK then we try to apply the pending
        // renames if any
        (pending.hasPendingRenames() &&
         mlir::failed(pending.applyPendingRenames())))
      signalPassFailure();
  }
};

} // namespace

std::unique_ptr<OperationPass<ModuleOp>> createSplitComponentBodyPass() {

  return std::make_unique<SplitComponentBodyPass>();
}

} // namespace zkc::Zmir
